---
params:
      set_target: ""
title: "`r paste(params$set_target, 'dashboard')`"
author: "Georgia Tsagkogeorga"
output:
  html_document:
    toc: true
    toc_depth: 5
    toc_float: true
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r, echo=FALSE, include=FALSE}
library(org.Hs.eg.db)
library(data.table)
library(readxl)
library(DT)
library(tidyr)
library(dplyr)
library(stringr)
library(RColorBrewer)
library(ggplot2)
library(ggthemes)
library(egg)
library(ggpubr)
library(plotly)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
target = params$set_target
target_annotations <- AnnotationDbi::select(org.Hs.eg.db, keys = target, columns=c("ENSEMBL", "SYMBOL"), keytype = "SYMBOL")
target_ensembl_id <- unique(target_annotations$ENSEMBL)
detach("package:org.Hs.eg.db", unload = T)
```
\
\
\

#### Open Targets Platform

The Open Targets Platform builds and scores target-disease associations to assist in drug target identification and prioritisation, by integrating publicly available datasets including data generated by the Open Targets consortium. It also integrates relevant annotation information about targets, diseases, phenotypes, and drugs, as well as their most relevant relationships. See link for `r target` in Open Targets Platform: `r paste0("https://platform.opentargets.org/target/", target_ensembl_id)`.
\
\
\


**TCGA cancer types in Open Targets**
```{r, echo=FALSE, warning=FALSE}
disease_ids = list("LAML"= "EFO_0000222", # acute myeloid leukemia
               "ACC"= "EFO_1000796", # adrenal cortex carcinoma
               "BLCA"= "EFO_0006544", # bladder transitional cell carcinoma
               "LGG"= "MONDO_0021637", # low grade glioma
               "BRCA"= "EFO_1000307", # invasive breast carcinoma
               "CESC"= "EFO_1000172", # cervical squamous cell carcinoma
               "CHOL"= "EFO_0005221", # cholangiocarcinoma
               "LCML"= "EFO_0000339", # chronic myelogenous leukemia
               "COAD"= "EFO_1001949", # colon adenocarcinoma
               "ESCA"= "EFO_0002916", # esophageal carcinoma
               "GBM"= "EFO_0000519", # glioblastoma multiforme
               "HNSC"= "EFO_0000181", # head and neck squamous cell carcinoma
               "KICH"= "EFO_0000335", # chromophobe renal cell carcinoma
               "KIRC"= "EFO_0000349", # clear cell renal carcinoma
               "KIRP"= "EFO_0000640", # papillary renal cell carcinoma
               "LIHC"= "EFO_0000182", # hepatocellular carcinoma
               "LUAD"= "EFO_0000571", # lung adenocarcinoma
               "LUSC"= "EFO_0000708", # squamous cell lung carcinoma
               "DLBC"= "EFO_0000403", # diffuse large B-cell lymphoma
               "MESO"= "EFO_0000588", # mesothelioma
               "OV"= "EFO_1000043", # ovarian serous cystadenocarcinoma
               "PAAD"= "EFO_1000044", # pancreatic adenocarcinoma
               "PCPG"= "EFO_0020005", # pheochromocytoma-paraganglioma
               "PRAD"= "EFO_0000673", # prostate adenocarcinoma
               "READ"= "EFO_0005631", # rectal adenocarcinoma
               "SARC"= "EFO_0000691", # sarcoma
               "SKCM"= "EFO_0000389", # cutaneous melanoma
               "STAD"= "EFO_0000503", # gastric adenocarcinoma
               "TGCT"= "EFO_1000566", # testicular germ cell tumor
               "THYM"= "EFO_1000581", # thymoma
               "THCA"= "EFO_0002892", # thyroid carcinoma
               "UCS"= "EFO_1000613", # uterine carcinosarcoma
               "UCEC"= "EFO_1001512", # endometrial carcinoma
               "UVM"= "EFO_1000616" # uveal melanoma
)
tcga_EFO <- data_frame(Abbr = names(disease_ids), "EFO" = unlist(disease_ids))
tcga_names <- read.table("~/New_targets/TCGA_cBioPortal/TCGA_studies.tsv", sep = "\t", header = T)

tcga_info <- merge(tcga_names, tcga_EFO, by="Abbr")
tcga_info$Open_Targets_associations <- paste0('<a href="https://platform.opentargets.org/disease/', tcga_info$EFO, '">', tcga_info$EFO,'</a')
tcga_info$EFO <- NULL
datatable(tcga_info, rownames = FALSE, escape = FALSE,
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(tcga_info), lineHeight='50%', "white-space"="nowrap")
rm(disease_ids, tcga_names, tcga_EFO)
```
\

For each cancer type as defined by the TCGA cohorts, we obtained all disease-target associations in Open Targets Platform. The table below shows the overall and evidence-based scores (**Overall_score**, **Genetic_association_score**, etc.), as well as the **Ranking** of `r target` (if present) among all other targets. For reference, the score range (**Score_range**) for all targets associated with a given disease is also provided. **Interesting targets should be ranked near the top with a high overall score**.


```{r, echo=FALSE, warning=FALSE}
open_targets_tcga <- read.csv("~/New_targets/Target_profile/input_data/OpenTargets_TCGA_targets.csv", header = T)
tcga_score_ranges <- open_targets_tcga %>% group_by(TCGA_cohort) %>% arrange(desc(overall_score)) %>% mutate(score_range=paste0(round(range(overall_score), digits = 3), collapse = "-")) %>% mutate(ranking = row_number())
open_targets_profile <- tcga_score_ranges %>% filter(gene_symbol == target) %>% select(gene_symbol, TCGA_cohort, ranking, score_range, overall_score, c(12:18))
colnames(open_targets_profile) <- str_to_title(colnames(open_targets_profile))
colnames(open_targets_profile)[c(2, 11)] <- c("TCGA_cohort", "RNA_expression_score")

datatable(open_targets_profile, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(open_targets_profile), lineHeight='50%') %>% formatRound(columns = names(open_targets_profile)[5:12], digits = 3)
rm(open_targets_tcga, tcga_score_ranges)
```
\
\

#### DepMap
```{r, echo=FALSE, warning=FALSE}
model_meta <- read.csv("~/New_targets/Target_profile/input_data/DepMap_23Q4/Model.csv", sep= ",", header = TRUE, check.names = FALSE)
CRISPR_scores <- fread("~/New_targets/Target_profile/input_data/DepMap_23Q4/CRISPRGeneEffect.csv", sep= ",", data.table = FALSE)
names(CRISPR_scores)[1] <- "ModelID"
RNAi_scores <- fread("~/New_targets/Target_profile/input_data/DepMap_23Q2/D2_combined_gene_dep_scores.csv", sep = ",", data.table = F)
model_passport <- read.csv("~/New_targets/Target_profile/input_data/DepMap_23Q4/model_list_20240110.csv", header = T, check.names = FALSE, na.strings = "")
model_passport <- model_passport[, c("model_id", "model_name", "BROAD_ID", "tissue", "cancer_type", "msi_status", "mutational_burden")]
colnames(model_passport)[3] <- "ModelID"

rownames(RNAi_scores) <- RNAi_scores$V1
RNAi_scores$V1 <- NULL
RNAi_scores <- t(RNAi_scores)
RNAi_scores <- as.data.frame(RNAi_scores)
RNAi_scores$ModelID <- sapply(rownames(RNAi_scores), function(x) model_meta$ModelID[match(x, model_meta$CCLEName)])
RNAi_scores <- RNAi_scores[!is.na(RNAi_scores$ModelID),]

t <- colnames(CRISPR_scores)[grep(paste0("^", target, " "), colnames(CRISPR_scores))]
target_essentiality_score <- merge(CRISPR_scores[,c("ModelID", t)], RNAi_scores[,c("ModelID", t)], by="ModelID", all = T, suffixes = c(" CRISPR"," RNAi"))

depmap_profile <- merge(target_essentiality_score, model_passport, by="ModelID")
depmap_profile <- depmap_profile[,c(1,5,2:3,7,6,8:9,4)]
names(depmap_profile)[3:4] <- c("CRISPR", "RNAi")
#depmap_profile <- depmap_profile %>% filter(!is.na(CRISPR) | !is.na(RNAi))
```

```{r, echo=FALSE, warning=FALSE}
screen_scores <- depmap_profile %>% drop_na() %>% select(CRISPR, RNAi)
score_cor <- cor.test(screen_scores$CRISPR, screen_scores$RNAi, method = "pearson")
P <- score_cor$p.value
r <- score_cor$estimate
x = min(screen_scores$CRISPR)
```

The plots below show the DepMap essentiality profile of `r target` based on CRISPR (red) and RNAi (blue) screens (DepMap release 23Q4). A lower score means that the target is more likely to be dependent in a given cell line. A score of 0 is equivalent to a gene that is not essential, whereas a score of -1 corresponds to the median of all common essential genes. A cell line is considered dependent on the target if it has an essentiality score below -0.5.

The plot on the right shows the correlation of CRISPR and RNAi scores for `r target` (`r paste0("r=", format(r, digits = 2), ", p=", format(P, digits = 2))`). Each point corresponds to a cell line and is coloured by lineage.

```{r, echo=FALSE, warning=FALSE, out.width='100%'}
data <- gather(depmap_profile, screen, score, CRISPR:RNAi, factor_key=TRUE)
p1 <- data %>%
  ggplot(aes(x=score, colour=screen, fill=screen, label=model_name)) +
  geom_rug(size = 0.1, alpha = 0.8) +
  geom_density(alpha=.4) +
  theme(legend.position = "bottom")
```

```{r, echo=FALSE, warning=FALSE, out.width='100%'}
p2 <- depmap_profile %>%
  drop_na() %>%
  ggplot(aes(x=CRISPR, y=RNAi, label=model_name)) +
  geom_point(aes(col=cancer_type)) +
  theme(legend.position = "none")
```

```{r, echo=FALSE, warning=FALSE, out.width='100%'}
subplot(p1, p2, titleY = TRUE, titleX = TRUE, margin = 0.05)
```

\
\

**CRISPR** and **RNAi** essentiality scores of `r target` for each cell line are also provided in the table below. **ModelID** is the DepMap cell line ID. Empty cells denote NAs, i.e., the gene was not screened or the score is not available for a given cell line.

```{r, echo=FALSE, warning=FALSE}
datatable(depmap_profile, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(depmap_profile), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = names(depmap_profile)[3:4], digits = 3)
```
\
\
\
\

#### MSI/MSS status

```{r, echo=FALSE, warning=FALSE}
depmap_profile_MSI_status <- depmap_profile %>% filter(!is.na(CRISPR) | !is.na(RNAi)) %>% filter(!is.na(msi_status))
msi_mss_wilcox <- lapply(3:4, function(x) wilcox.test(depmap_profile_MSI_status[[x]] ~ depmap_profile_MSI_status$msi_status)$p.value)
names(msi_mss_wilcox) <- names(depmap_profile_MSI_status)[3:4]
```

Microsatellite instability (MSI) is the condition of genetic hypermutability that results in the number of repeated DNA bases in a microsatellite being different from what it was when the microsatellite was inherited. MSI is most often found in colorectal cancer, gastric cancer, and endometrial cancer, but it may also be found in many other types of cancer. There are 585 cell lines in total that have been annotated with a MSI status in DepMap 23Q4 release, as defined by the Cell Model Passports. Of these, `r target` been screened in `r length(depmap_profile_MSI_status[!is.na(depmap_profile_MSI_status$CRISPR),]$model_name)` and `r length(depmap_profile_MSI_status[!is.na(depmap_profile_MSI_status$RNAi),]$model_name)` cell lines using CRISPR and RNAi, respectively. To explore synthetic lethality to MSI or MSS and thus a potential patient population, we compared the DepMap essentiality scores for `r target` between Microsatellite Instable (MSI) and Microsatellite Stable (MSS) cell lines using the Wilcoxon test.

**Wilcoxon test all cell lines combined** \
CRISPR p=`r format(msi_mss_wilcox[["CRISPR"]], digits = 3)`, RNAi p=`r format(msi_mss_wilcox[["RNAi"]], digits = 3)`
\

```{r, echo=FALSE, warning=FALSE, fig.align='center'}
p3 <- depmap_profile_MSI_status %>%
  drop_na(msi_status) %>%
  gather(screen, score, CRISPR:RNAi, factor_key=TRUE) %>%
  ggplot(aes(y=score, x=screen, fill=msi_status, color=msi_status, label=cancer_type)) +
  geom_boxplot(alpha=.4, outlier.shape = NA) +
  geom_point(position=position_jitterdodge(jitter.width = 0.1))
ggplotly(p3) %>% layout(boxmode='group')
```


**Wilcoxon test results by lineage**\
Minimum number of samples required for a comparison was set to 4. The Wilcoxon test p-value for each lineage and screen is indicated in each plot as CRISPR and RNAi, respectively. \

```{r, echo=FALSE, warning=FALSE, fig.height=6, fig.width=8, out.width='100%'}
celline_counts_by_cancer_type <- as.data.frame(table(depmap_profile_MSI_status[,c("msi_status", "cancer_type")]))
celline_counts_by_cancer_type <- celline_counts_by_cancer_type %>% pivot_wider(names_from = msi_status, values_from = Freq) %>% filter(MSI >= 4 & MSS >= 4)
depmap_profile_MSI_status_cancer_type <- depmap_profile_MSI_status %>% filter(cancer_type %in% celline_counts_by_cancer_type$cancer_type)

wilcox_list <- list()
for (t in celline_counts_by_cancer_type$cancer_type) {
  depmap_profile_MSI_status_t <- depmap_profile_MSI_status %>% filter(cancer_type == t)
  msi_mss_wilcox <- lapply(3:4, function(x) wilcox.test(depmap_profile_MSI_status_t[[x]] ~ depmap_profile_MSI_status_t$msi_status)$p.value)
  names(msi_mss_wilcox) <- names(depmap_profile_MSI_status_t)[3:4]
  wilcox_list[[t]] <- as.data.frame(msi_mss_wilcox, row.names = t)
}
wilcox_res <- do.call("rbind", wilcox_list)
wilcox_res$wilcox <- sapply(1:dim(wilcox_res)[1], function(x) paste0("CRISPR=",format(wilcox_res[x, 1], digits = 3), ", RNAi=", format(wilcox_res[x, 2], digits = 3)))

p4 <- depmap_profile_MSI_status_cancer_type %>%
  drop_na(msi_status) %>%
  mutate(wilcox = wilcox_res[match(depmap_profile_MSI_status_cancer_type$cancer_type, rownames(wilcox_res)), "wilcox"]) %>%
  gather(screen, score, CRISPR:RNAi, factor_key=TRUE) %>%
  ggplot(aes(y=score, x=screen, fill=msi_status, color=msi_status, label=cancer_type)) +
  geom_boxplot(alpha=.4, outlier.shape = NA) +
  geom_point(position=position_jitterdodge(jitter.width = 0.2)) +
  facet_wrap(. ~ cancer_type + wilcox, nrow = 2) +
  theme(legend.position = "top")
p4
```
\
\

#### Mutational burden

Mutational burden describes the number of somatic mutations (SNV's/INDEL's) detected in a model relative to the total number of bases sequenced. Here, we compare whether there is a correlation between DepMap CRISPR and/or RNAi essentiality scores of `r target` with cell line mutational burden.


```{r, echo=FALSE, warning=FALSE, fig.height=4, fig.width=10, fig.align='center', message=FALSE}
p5 <- depmap_profile %>%
  ggplot(aes(x = CRISPR, y = log(mutational_burden))) +
  geom_point(aes(x = CRISPR, y = log(mutational_burden), col=msi_status, label=model_name))+
  stat_cor(method = "spearman", label.x.npc = "left", size=4) +
  geom_smooth(method = "lm") +
  theme(legend.position = "top")
p6 <- depmap_profile %>%
  ggplot(aes(x = RNAi, y = log(mutational_burden))) +
  geom_point(aes(x = RNAi, y = log(mutational_burden), col=msi_status, label=model_name))+
  stat_cor(method = "spearman", label.x.npc = "left", size=4) +
  geom_smooth(method = "lm") +
  theme(legend.position = "top")
ggarrange(p5, p6, nrow = 1)
```
\
\

**Correlation results by cancer type**\
Minimum number of samples required for a comparison was set to 10. The Spearman correlations and p-value for each cancer type and screen is indicated in each plot. \


```{r, echo=FALSE, warning=FALSE}
mutational_burden_by_cancer_type <- function(screen) {
  cor_table <- depmap_profile %>%
    rename("screen" = screen) %>%
    drop_na(screen) %>%
    drop_na(mutational_burden) %>%
    group_by(cancer_type) %>%
    mutate(N = n()) %>%
    filter(N > 10)

  if ( nrow(cor_table) > 0 ) {
    cor_table <- cor_table %>%
      rename("screen" = screen) %>%
      group_by(cancer_type) %>%
      summarise(
        'essentiality_range' = paste0("[", format(min(screen), digits = 3), ", ", format(max(screen), digits = 3), "]"),
        'essentiality_delta' = format(min(screen) - max(screen), digits = 3),
        'N' = n(),
        'Cor' = cor.test(screen,log(mutational_burden), na.rm=TRUE, method = "spearman")$estimate,
        'Pvalue' = cor.test(screen,log(mutational_burden), na.rm=TRUE, method = "spearman")$p.value,
        'cor' = paste0("cor=", round(cor.test(screen,log(mutational_burden), na.rm=TRUE, method = "spearman")$estimate, 2), " p-value=", round(cor.test(screen,log(mutational_burden), na.rm=TRUE, method = "spearman")$p.value, 3)))

    p7 <- depmap_profile %>%
      rename("screen" = screen) %>%
      drop_na(screen) %>%
      drop_na(mutational_burden) %>%
      group_by(cancer_type) %>%
      mutate(N = n()) %>%
      filter(N > 10) %>%
      left_join(cor_table, by="cancer_type") %>%
      ggplot(aes(y=log(mutational_burden), x=screen, label=cancer_type)) +
      geom_point(aes(x = screen, y = log(mutational_burden), col=msi_status)) +
      geom_smooth(method = "lm") +
      facet_wrap(~ cancer_type + cor, ncol = 4, scales = "free") +
      xlab(screen) +
      theme(legend.position = "top")

    return(p7)
  }
}
```

```{r, echo=FALSE, warning=FALSE, fig.height=12, fig.width=8, out.width='100%', message=FALSE}
mutational_burden_by_cancer_type(screen = "CRISPR")
```
\

```{r, echo=FALSE, warning=FALSE, fig.height=12, fig.width=8, out.width='100%', message=FALSE}
mutational_burden_by_cancer_type(screen = "RNAi")
```

\
\

#### Project Score - Cancer Dependency Map v1

Project Score provides a computational framework to assign each gene a target priority score that integrates CRISPR knockout gene fitness effects with genomic biomarker and patient data. All genes are assigned a target priority score between 0 – 100 from lowest to highest priority, with the fitness effect of gene knockout in individual cell lines derived from the CRISPR-Cas9 screening accounting for 70% of total score. The biomarker and tumour prevalence account for 30% of total score. In addition, each gene was also assigned to 1 of 10 tractability buckets, with 1 indicating the highest tractability. Tractability group 1 (buckets 1–3) comprises targets of approved anticancer drugs or compounds in clinical or preclinical development. Tractability group 2 (buckets 4–7) contains priority targets without drugs in clinical development but with evidence that support target tractability. Lastly, group 3 (buckets 8–10) includes priority targets that have weak or no support, or a lack of information that could inform tractability. **Interesting targets should be ranked near the top with a high overall score.**


```{r, echo=FALSE, warning=FALSE}
Project_Score_scores <- read.csv("~/New_targets/Target_profile/input_data/Project_Score/depmap-priority-scores.csv", header = T)
Project_Score_score_range <- Project_Score_scores %>% group_by(analysis.name) %>% arrange(desc(score)) %>% mutate(score_range=paste0(round(range(score), digits = 3), collapse = "-")) %>% mutate(ranking = row_number())
```

For each cancer type (**Analysis.name**), we parse the target tractability assignment (**Tractability.bucket**), priority score (**Score**), as well as its **Ranking** (if available) among all other targets in Project Score. For reference, the priority score range (**Score_range**) for all targets in a given analysis is also provided.

```{r, echo=FALSE, warning=FALSE, results='asis'}
if ( target %in% unique(Project_Score_scores$symbol)) {
  Project_Score_profile <- Project_Score_score_range %>% filter(symbol == target) %>% select(symbol, analysis.id, analysis.name, tractability.bucket, score, ranking, score_range)
  target_projectscore_id <- unique(Project_Score_profile$gene.id)
  colnames(Project_Score_profile) <- str_to_title(colnames(Project_Score_profile))
  datatable(Project_Score_profile, rownames = FALSE,
            extensions = 'Buttons',
            filter = "top",
            options = list(
              dom = 'Bfrtip',
              pageLength = 10,
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>% formatStyle(columns = names(Project_Score_profile), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = "Score", digits = 3)
} else {
  cat(paste0("No data available for ", target))
}
```

```{r, echo=FALSE, warning=FALSE, results='asis'}
if ( target %in% unique(Project_Score_scores$symbol)) {
  Project_Score_profile <- Project_Score_score_range %>% filter(symbol == target) %>% select(gene.id, analysis.name)
  target_projectscore_id <- unique(Project_Score_profile$gene.id)
  cat(paste0("For more details, see the link for ", target, " in Project Score: ", "https://score.depmap.sanger.ac.uk/gene/", target_projectscore_id, "\n"))
}
rm(Project_Score_scores, Project_Score_score_range)
```

\
\

#### Pacini *et al Cancer Cell* 2024 - Cancer Dependency Map v2

In their paper, Pacini *et al* constructed a second-generation map of cancer dependencies by annotating 930 cancer cell lines with multi-omic data and analyzing relationships between molecular markers and cancer dependencies derived from CRISPR-Cas9 screens. This allowed them to identify dependency-associated gene expression markers beyond driver genes, including many gene addiction relationships driven by gain of function rather than synthetic lethal effects.

To nominate candidate anti-cancer therapeutic targets, they considered a combination of three weighted factors. The three factors were the strength of the effect on cellular fitness following target gene depletion (fitness score), the presence of a marker for dependency (DMA score), and evidence linking the dependency and marker (PPI network score). For each target the authors selected the combination of the DMA and PPI network score with the highest value. They calculated a threshold based on the priority scores of approved drug targets compared with non approved targets and defined the set of priority targets as those above the threshold. This Score2 framework integrates multiple layers of evidence to enable a systematic and evidence-based approach for candidate target identification and prioritization.

For each cancer type (**Cancertype**), we parse the target priority score (**Score**), the tractability bucket based on annotation from the OpenTargets platform (**Tractability**), and the grouping ranging from 1-3 (**Group**), defined as targets with approved or pre-clinical drugs (group 1), with supporting evidence of future tractability (group 2), and those with weak or no evidence of future tractability (group 3). We also provide some other attributes from the paper, such as type of compound available corresponding to tractability bucket (**Moltype**), marker class (**Markerclass**), direction of effect between marker and gene dependency (**Association_effect**), name and type of marker (**Marker**). **Interesting targets should have a high priority score.**

```{r, echo=FALSE, warning=FALSE, error=FALSE, results='asis'}
cancertype_priority_scores_v2 <- read_excel("~/New_targets/Target_profile/input_data/Cancer_Cell/Priority_scores.xls", sheet = 2)
pancancer_priority_scores_v2 <- read_excel("~/New_targets/Target_profile/input_data/Cancer_Cell/Priority_scores.xls", sheet = 3)
names(pancancer_priority_scores_v2)[1] <- "cancerType"

depmap_priority_scores_v2 <- rbind(pancancer_priority_scores_v2, cancertype_priority_scores_v2)
depmap_priority_scores_v2$cancerType <- gsub("\\.", " ", depmap_priority_scores_v2$cancerType)
depmap_priority_scores_v2$cancerType <- gsub("PANCAN", "Pan-Cancer", depmap_priority_scores_v2$cancerType)
```
\

```{r, echo=FALSE, warning=FALSE, error=FALSE, results='asis'}
names(depmap_priority_scores_v2)[2] <- "symbol"
if ( target %in% unique(depmap_priority_scores_v2$symbol)) {

  RNA_genes_Cancer_Cell <- depmap_priority_scores_v2 %>% filter(symbol == target)

  names(RNA_genes_Cancer_Cell) <- str_to_title(names(RNA_genes_Cancer_Cell))
  names(RNA_genes_Cancer_Cell)[3] <- "Score"
  datatable(RNA_genes_Cancer_Cell, rownames = FALSE,
            extensions = 'Buttons',
            filter = "top",
            options = list(
              dom = 'Bfrtip',
              pageLength = 15,
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>% formatStyle(columns = names(RNA_genes_Cancer_Cell), "white-space"="nowrap", lineHeight='50%') %>%
    formatRound(columns="Score", digits=3)
} else {
  cat(paste0("No data available for ", target))
}
```
\
\

#### Synthetic Lethality to Loss-of-Function mutations

A synthetic lethal interaction between two genes occurs when the perturbation of either gene alone is viable, but the perturbation of both genes simultaneously results in the loss of viability. Here we evaluate whether genetic perturbation of `r target` by either CRISPR or RNAi appears to be more lethal in presence of Loss-of-Function (LoF) mutations in other genes of the genome. We compared the `r target` essentiality scores of cell lines having LoF mutations in a given gene to those that do not, and selected genes for which the LoF or "mutated" group shows a lower essentiality score (higher sensitivity) to `r target` compared to the 'normal' group. We performed Wilcoxon one-side test for genes with a minimum sampling size of 5 mutated and 5 normal cell line per indication.

The tables below show significant associations found (p-value<0.05), where column names correspond to the following: \
**Gene**: Gene tested for synthetic lethal association to target  \
**N_normal**: Number of cell lines in which the gene does not appear to have any LoF mutations (normal)  \
**N_mutated**:  Number of cell lines in which the gene has one or more LoF mutations (mutated)  \
**Median_normal**: Median essentiality score for cell lines with normal mutation status  \
**Median_mutated**: Median essentiality score for cell lines with mutated status \
**MSI_normal**: Number of MSI cell lines in which the gene appear as normal  \
**MSI_mutated**:  Number of MSI cell lines in which the gene has LoF mutations \
**Wilcox_pval**: Wilcoxon test p-value  \
**Delta**: Difference between Median_normal - Median_mutated to capture the effect size  \

Interesting associations should have a large effect size **Delta**. In addition, the median essentiality score for cell lines with LoF mutations (**Median_mutated**) should be below -0.5 to be considered dependent on the target.

\
\

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Read mutation data (source DepMap 23Q4)
mutation_data <- fread("~/New_targets/Target_profile/input_data/DepMap_23Q4/OmicsSomaticMutations.csv", data.table = F)
# Count mutations with likely LoF by gene and cell line
LoF_mutations <- mutation_data %>%
  group_by(HugoSymbol, ModelID) %>%
  summarise(n = sum(LikelyLoF)) %>%
  pivot_wider(names_from = HugoSymbol, values_from = n, values_fill = 0)
# Focus on mutations annotated as likely LoF, i.e. a gene either "LoF" or normal
df <- LoF_mutations %>%
  mutate(across(2:ncol(LoF_mutations), ~ ifelse(. > 0, "mutated", "normal")))
rm(mutation_data, LoF_mutations)

# Focus on mutations annotated as likely LoF, i.e. a gene either "LoF" or normal
essentiality_vs_mutation_status_by_ctype <- function(df, target, screen) {
  # filter cell models not tested in the screen and select genes mutated and non mutated in minimum 10 (5+5) cell lines in a given cancer type
  if ( screen == "CRISPR") {
    target_essentiality_score <- CRISPR_scores[,c("ModelID", colnames(CRISPR_scores)[grep(paste0("^", target, " "), colnames(CRISPR_scores))])]
  }
  if (screen == 'RNAi') {
    target_essentiality_score <- RNAi_scores[,c("ModelID", colnames(RNAi_scores)[grep(paste0("^", target, " "), colnames(RNAi_scores))])]
  }
  if ( ncol(target_essentiality_score) == 2 ) {
    target_essentiality_score <- merge(target_essentiality_score, model_passport[,c("ModelID", "tissue", "cancer_type", "msi_status", "mutational_burden")], by="ModelID")
    colnames(target_essentiality_score)[2] <- screen
    # Calculate correlations across all cancer types
    # Filter cell models that have not been tested in the screen, and select genes mutated and non mutated in minimum 10 cell lines, 5 and 5 respectively

    data <- merge(target_essentiality_score, df, by="ModelID")
    data_all <- data %>%
      rename("screen" = screen) %>%
      drop_na(screen) %>%
      pivot_longer(c(7:ncol(data)), names_to = "Gene", values_to = "mutational_status") %>%
      group_by(Gene) %>%
      filter(sum(mutational_status == "mutated") >= 5 & sum(mutational_status == "normal") >= 5)
    # perform Wilcox test by Gene and apply FDR correction
    if ( nrow(data_all) >= 10 ) {
      wilcox_res <- data_all %>%
        do(w = wilcox.test(screen ~ mutational_status, data=., paired=FALSE, alternative = "less")) %>%
        summarise(Gene, Wilcox_pval = w$p.value)
      # calculate medians and sampling sizes for each gene by mutational status
      other_stats <- data_all %>%
        group_by(Gene, mutational_status) %>%
        mutate(Median=median(screen)) %>%
        mutate(N=n()) %>%
        mutate(MSI=sum(msi_status == "MSI", na.rm = T)) %>%
        select(Gene, mutational_status, N, Median, MSI) %>%
        pivot_wider(names_from = mutational_status, values_from = c(N, Median, MSI), values_fn = unique) %>%
        mutate(cancer_type = "All cancers")
      # join results. order by padj and export to csv
      essentiality_vs_mutation_status <- inner_join(other_stats[,c(1,8,2:7)], wilcox_res, by="Gene") %>% arrange(Wilcox_pval)
    }
    # Calculate correlations by cancer type
    data_ctype <- data %>%
      rename("screen" = screen) %>%
      drop_na(screen) %>%
      pivot_longer(c(7:ncol(data)), names_to = "Gene", values_to = "mutational_status") %>%
      group_by(Gene, cancer_type) %>%
      filter(sum(mutational_status == "mutated") >= 5 & sum(mutational_status == "normal") >= 5)
    # perform Wilcox test by Gene and cancer type, and apply FDR correction
    if ( nrow(data) >= 10 ) {
      wilcox_res <- data_ctype %>%
        do(w = wilcox.test(screen ~ mutational_status, data=., paired=FALSE, alternative = "less")) %>%
        summarise(across(c(Gene, cancer_type)), Wilcox_pval = w$p.value)
      # calculate medians and sampling sizes for each gene by cancer type and mutational status
      other_stats <- data_ctype %>%
        group_by(Gene, cancer_type, mutational_status) %>%
        mutate(Median=median(screen)) %>%
        mutate(N=n()) %>%
        mutate(MSI=sum(msi_status == "MSI", na.rm = T)) %>%
        select(Gene, cancer_type, mutational_status, N, Median, MSI) %>%
        pivot_wider(names_from = mutational_status, values_from = c(N, Median, MSI), values_fn = unique)
      # join results, order by padj and export to csv
      essentiality_vs_mutation_status_ctype <- inner_join(other_stats, wilcox_res, by=c("Gene", "cancer_type")) %>% arrange(Wilcox_pval)

      essentiality_vs_mutation_status_res <- rbind(essentiality_vs_mutation_status, essentiality_vs_mutation_status_ctype)
      colnames(essentiality_vs_mutation_status_res)[2] <- str_to_title(colnames(essentiality_vs_mutation_status_res)[2])

      # return results tibble
      essentiality_vs_mutation_status_res <- essentiality_vs_mutation_status_res %>%
        filter(Wilcox_pval < 0.05) %>%
        mutate(Delta = Median_normal - Median_mutated) %>%
        arrange(desc(Delta))
      rm(wilcox_res, other_stats, data, data_all)
      return(essentiality_vs_mutation_status_res)
    }
  }
}

```

**Synthetic lethal mutations to `r target` CRISPR essentiality**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
SL_LoF_mutations_CRISPR <- essentiality_vs_mutation_status_by_ctype(target = target, df = df, screen = "CRISPR")
datatable(SL_LoF_mutations_CRISPR, rownames = FALSE,
            extensions = 'Buttons',
            filter = "top",
            options = list(
              dom = 'Bfrtip',
              pageLength = 10,
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>% formatStyle(columns = names(SL_LoF_mutations_CRISPR), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = c("Median_normal", "Median_mutated", "Wilcox_pval", "Delta"), digits = 3)

```

\
\
**Synthetic lethal mutations to `r target` RNAi essentiality**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
SL_LoF_mutations_RNAi <- essentiality_vs_mutation_status_by_ctype(target = target, df = df, screen = "RNAi")
datatable(SL_LoF_mutations_RNAi, rownames = FALSE,
            extensions = 'Buttons',
            filter = "top",
            options = list(
              dom = 'Bfrtip',
              pageLength = 10,
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>% formatStyle(columns = names(SL_LoF_mutations_RNAi), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = c("Median_normal", "Median_mutated", "Wilcox_pval", "Delta"), digits = 3)

```

\
\
\

#### Synthetic Lethality to ecDNA

Extrachromosomal DNA (ecDNA) are large (~kilo to megabase) acentric, atelomeric, circular DNAs that enable cancer cells to amplify key driver genes outside of chromosomes and change how these genes are regulated, replicated and divided. More common than expected, ecDNA occur in as high as 14-20% of tumors from oncology patients and have been established cytogenetic markers for malignancy and hard-to-treat tumors for 40 years (often called double minute chromosomes). Despite their clinical relevance, it remains largely unknown how frequently they occur in cancer cell line model systems. CytoCellDB is a recently developed resource that provides queryable karyotype information for 577 DepMap cell lines, including information on ecDNA, HSRs and other chromosomal aberrations (`r paste0("https://https://cytocelldb.unc.edu/")`).

Same as in the synthetic lethality analyses above, here we evaluate whether genetic perturbation of `r target` by either CRISPR or RNAi appears to be more lethal in presence of ecDNA. We compared the `r target` essentiality scores of cell lines having ecDNA (as per CytoCellDB annotation) to those that do not, looking for indications in which the ecDNA+ group shows a lower essentiality score (higher sensitivity) to `r target` compared to the ecDNA- group. We performed Wilcoxon one-side test for cancer types with a minimum sampling size of 5 ecDNA+ and 5 ecDNA- cell lines, respectively.

The table below summarises all synthetic lethality test results for both CRISPR and RNAi screens, where column names correspond to the following: \
**Screen**: Essentiality scores used for testing  \
**N_N**: Number of ecDNA- cell lines  \
**N_Y**:  Number of ecDNA+ cell lines   \
**Median_N**: Median essentiality score for ecDNA- cell lines  \
**Median_Y**: Median essentiality score for ecDNA+ cell lines  \
**MSI_N**: Number of MSI cell lines among the ecDNA- group \
**MSI_Y**:  Number of MSI cell lines among the ecDNA+ group \
**Wilcox_pval**: Wilcoxon test p-value  \
**Delta**: Difference between Median_N - Median_Y to capture the effect size  \

Interesting associations should have a low **Wilcox_pval**<0.05, and a large effect size **Delta**. In addition, the median essentiality score for ecDNA+ cell lines (**Median_Y**) should be below -0.5 to be considered dependent on the target.

\
\


```{r, echo=FALSE}
# Read CytoCellDB ecDNA cell line info
ecDNA_data <- read.csv("~/New_targets/Target_profile/input_data/ecDNA/CytocellDB ecDNA cell lines.csv", header = T, na.strings = "")
ecDNA_data <- ecDNA_data[,c("DepMap_ID", "ECDNA", "HSR")]
names(ecDNA_data)[1] <- "ModelID"

df <- merge(ecDNA_data, model_passport[,c("ModelID", "tissue", "cancer_type", "msi_status", "mutational_burden")], by="ModelID")
cancer_types_to_test <- df %>% group_by(cancer_type) %>% filter(sum(ECDNA == "Y") >= 5 & sum(ECDNA == "N") >= 5)
cancer_types_to_test <- unique(cancer_types_to_test$cancer_type)

essentiality_vs_ecDNA_status <- function(target, screen, variable, ctype = "All cancers") {
  if ( screen == "CRISPR") {
    target_essentiality_score <- CRISPR_scores[,c("ModelID", colnames(CRISPR_scores)[grep(paste0("^", target, " "), colnames(CRISPR_scores))])]
  }
  if (screen == 'RNAi') {
    target_essentiality_score <- RNAi_scores[,c("ModelID", colnames(RNAi_scores)[grep(paste0("^", target, " "), colnames(RNAi_scores))])]
  }
  if ( ncol(target_essentiality_score) == 2 ) {
    data <- merge(target_essentiality_score, df, by="ModelID")
    colnames(data)[2] <- screen

    # filter cell models that have not been tested in the screen, and select minimum 10 cell lines, 5 ecDNA/HSR and 5 not respectively
    data <- data %>% filter(if (ctype != "All cancers") cancer_type == ctype else TRUE)
    data <- data %>%
      rename("Screen" = screen) %>%
      rename("Variable" = variable) %>%
      drop_na(Screen) %>%
      drop_na(Variable) %>%
      filter(sum(Variable == "Y") >= 5 & sum(Variable == "N") >= 5)
    # perform Wilcox test by Gene and apply FDR correction
    if ( nrow(data) >= 10 ) {
      wilcox_res <- data %>%
        summarise(Gene = target, Screen = screen, Cancer_type = ctype, Wilcox_pval = wilcox.test(Screen ~ Variable, data=., paired=FALSE, alternative = "greater")$p.value)
      # calculate medians and sampling sizes for each gene by mutational status
      other_stats <- data %>%
        group_by(Variable) %>%
        mutate(Gene = target) %>%
        mutate(Median=median(Screen)) %>%
        mutate(N=n()) %>%
        mutate(MSI=sum(msi_status == "MSI", na.rm = T)) %>%
        select(Gene, Variable, N, Median, MSI) %>%
        pivot_wider(names_from = Variable, values_from = c(N, Median, MSI), values_fn = unique)
      # join results and export to csv
      essentiality_vs_variable <- inner_join(other_stats, wilcox_res)
      essentiality_vs_variable <- essentiality_vs_variable[,c(1,8:9,2:7,10)]
      # return results tibble
      return(essentiality_vs_variable)
    }
  }
}

```


**Synthetic lethality of `r target` to ecDNA**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
cor_results <- list()
if ( length(grep(paste0("^", target, " "), colnames(CRISPR_scores))) > 0 ) {
  cor_results[[paste0(target, "_CRISPR")]] <- essentiality_vs_ecDNA_status(target = target, screen = "CRISPR", variable = "ECDNA")
  for (cancer_type in cancer_types_to_test) {
    cor_result_ctype <- essentiality_vs_ecDNA_status(target = target, screen = "CRISPR", variable = "ECDNA", ctype = cancer_type)
    if (!is.null(cor_result_ctype)) {
      cor_results[[paste0(target, "_CRISPR_", cancer_type)]] <- cor_result_ctype
    }
  }
}
if ( length(grep(paste0("^", target, " "), colnames(RNAi_scores))) > 0 )  {
  cor_results[[paste0(target, "_RNAi")]] <- essentiality_vs_ecDNA_status(target = target, screen = "RNAi", variable = "ECDNA")
  for (cancer_type in cancer_types_to_test) {
    cor_result_ctype <- essentiality_vs_ecDNA_status(target = target, screen = "RNAi", variable = "ECDNA", ctype = cancer_type)
    if (!is.null(cor_result_ctype)) {
      cor_results[[paste0(target, "_RNAi_", cancer_type)]] <- cor_result_ctype
    }
  }
}

SL_ecDNA <- do.call("rbind", cor_results)
SL_ecDNA <- SL_ecDNA %>% mutate(Delta = Median_N- Median_Y)

datatable(SL_ecDNA, rownames = FALSE,
            extensions = 'Buttons',
            filter = "top",
            options = list(
              dom = 'Bfrtip',
              pageLength = 10,
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>% formatStyle(columns = names(SL_ecDNA), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = c("Median_N", "Median_Y", "Wilcox_pval", "Delta"), digits = 3)

```

\
\
\

#### TCGA mutations

Mutation data for `r target` across all TCGA cohorts were retrieved from cBioPortal and were combined into a mutation diagram, showing the counts of patients with a given mutation in TCGA. Circles are colored with respect to the mutation impact.


```{r, echo=FALSE, warning=FALSE}
tcga_studies <- list.files("~/New_targets/Target_profile/input_data/cBioPortal/mutation_data/")
tcga_studies <- gsub("_tcga_pan_can_atlas_2018.txt", "", tcga_studies)

tcga_list <- list()
for (study in tcga_studies) {
  mutation_data <- fread(paste0("~/New_targets/Target_profile/input_data/cBioPortal/mutation_data/", study, "_tcga_pan_can_atlas_2018.txt"), data.table = F, sep = "\t", check.names = F, na.strings = ".")
  mutation_data <- mutation_data[mutation_data$Hugo_Symbol == target,]
  if (dim(mutation_data)[1] > 0) {
  mutation_data$TCGA_study <- gsub("mutation_", "", study)
  tcga_list[[study]] <- mutation_data[,c("TCGA_study", "Hugo_Symbol", "Entrez_Gene_Id", "NCBI_Build", "Chromosome", "Start_Position", "End_Position", "Strand", "Consequence", "Variant_Classification", "Variant_Type", "Reference_Allele", "Tumor_Seq_Allele1", "Tumor_Seq_Allele2", "dbSNP_RS", "Tumor_Sample_Barcode", "Matched_Norm_Sample_Barcode", "Match_Norm_Seq_Allele1", "Match_Norm_Seq_Allele2", "t_ref_count", "t_alt_count", "n_ref_count", "n_alt_count", "HGVSc", "HGVSp", "HGVSp_Short", "Transcript_ID", "RefSeq", "Protein_position", "Codons", "Hotspot", "NCALLERS", "UNIPARC", "n_depth", "Feature", "CONTEXT", "Gene", "HGNC_ID", "MERGESOURCE", "t_depth", "SYMBOL_SOURCE", "Existing_variation", "SYMBOL", "VARIANT_CLASS", "PHENO", "BIOTYPE", "AFR_MAF", "DOMAINS", "Amino_acids", "Allele", "cDNA_position", "SIFT", "INTRON", "TREMBL", "AMR_MAF", "EAS_MAF", "CANONICAL", "DBVS", "all_effects", "GMAF", "SOMATIC", "IMPACT", "CDS_position", "COSMIC", "SWISSPROT", "EUR_MAF", "Feature_type", "HGVS_OFFSET", "PolyPhen", "FILTER")]
  }
  rm(mutation_data)
}
tcga_res <- do.call("rbind", tcga_list)
rownames(tcga_res) <- NULL
tcga_res <- tcga_res[,colSums(is.na(tcga_res))<nrow(tcga_res)]
rm(tcga_list)
```

```{r, echo=FALSE, warning=FALSE, out.width='100%', fig.height=2.5}
tcga_res_info <- tcga_res[, c("Chromosome", "Start_Position", "Strand", "Variant_Classification", "Variant_Type", "HGVSp_Short", "Protein_position", "Amino_acids", "IMPACT", "CDS_position")]
mutation_counts <- as.data.frame(table(tcga_res_info$Protein_position))
names(mutation_counts) <- c("Protein_position", "mutation_counts")

df <- merge(tcga_res_info, mutation_counts, by="Protein_position")
df <- df[!duplicated(df),]
df$Protein_position <- as.numeric(as.character(df$Protein_position))
df$IMPACT <- factor(df$IMPACT, levels = c("LOW", "MODERATE", "HIGH"))
df$Zscore <- format(round(scale(df$mutation_counts), 3), nsmall = 3)

xmax <- plyr::round_any(max(df$Protein_position), 100, f=ceiling)

impact.colors <- c(LOW = "#0CB702", MODERATE = "#FFC100", HIGH = "#FF0000")
p5 <- ggplot(df, aes(x=Protein_position, y=mutation_counts, colour = IMPACT, text=paste(Variant_Type, "/", Variant_Classification, "\n", HGVSp_Short, "\n", IMPACT, "\n", "Z-score=", Zscore))) +
  geom_segment( aes(x=Protein_position, xend=Protein_position, y=0, yend=mutation_counts), color="grey", size=0.5) +
  geom_point(size=2) +
  theme_light() +
  theme(
    panel.grid.major.x = element_blank(),
    panel.border = element_blank()
  ) +
  scale_x_continuous(breaks = seq(0, xmax, 100), limits = c(0, xmax)) +
  scale_color_manual(values=impact.colors) +
  xlab("Protein position") +
  ylab("# patients")
ggplotly(p5)
```

```{r, echo=FALSE, warning=FALSE}
df <- df[,c(1,11:12,2:10)]
names(df)[2] <- "#Patients"
datatable(df, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(df), lineHeight='50%', "white-space"="nowrap")
```

<details><summary>Click for **Complete mutation table**</summary>
\

```{r, echo=FALSE, warning=FALSE}
datatable(tcga_res, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(tcga_res), lineHeight='50%', "white-space"="nowrap")
```
</details>
\
\

To identify hotspot mutations genome-wide for each TCGA cohort, we calculated the frequency of all mutations in a given gene in the cohort, and scaled them to 0 (z-score conversion to the mean). Mutations present in at least four individuals and with a z-score greater than 2 standard deviations were selected as candidate hotspot mutations.
\

**Hotspot mutations by cohort**
\
```{r, echo=FALSE, message=FALSE, results='asis'}
in_files <- list.files(path = "~/New_targets/TCGA_cBioPortal/hotspot_mutations/", pattern = "_hotspot_mutations.csv", full.names = T)
in_files <- in_files[grep("Targets", in_files, invert = T)]
names(in_files) <- gsub(".*/", "", in_files)
names(in_files) <- gsub("_hotspot_mutations.csv", "", names(in_files))

mutations <- sapply(in_files, function(x)read.table(paste(x), header = T, sep = ",", check.names = F), simplify = F, USE.NAMES = T)
mutations <- mutations[lapply(mutations, nrow)>0]
for (cohort in names(mutations)) {
  mutations[[cohort]] <- mutations[[cohort]] %>% select(Hugo_Symbol, Freq, zscore, Chromosome, Start_Position, End_Position, Strand, Variant_Classification, IMPACT, Transcript_ID, RefSeq, Protein_position, HGNC_ID)
  mutations[[cohort]]$Chromosome <- as.character(mutations[[cohort]]$Chromosome)
  mutations[[cohort]]$HGNC_ID <- as.character(mutations[[cohort]]$HGNC_ID)
  mutations[[cohort]]$TCGA_study <- str_to_upper(cohort)
}

selected_mutations <- mutations %>% bind_rows %>% filter(Hugo_Symbol == target)

if (dim(selected_mutations)[1] > 0) {
  selected_mutations <- selected_mutations %>% group_by(Hugo_Symbol, TCGA_study, Freq, zscore, Chromosome, Start_Position, Strand, Transcript_ID, RefSeq) %>%
    summarise(Variant_Class = paste0(unique(Variant_Classification), collapse = "/"), Impact = paste0(unique(IMPACT), collapse = "/"))
  colnames(selected_mutations)[4] <- "Zscore"
  datatable(selected_mutations[, c(1:7,10:11,7:9)], rownames = FALSE,
            extensions = 'Buttons',
            filter = "top",
            options = list(
              dom = 'Bfrtip',
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>%
    formatStyle(columns = names(selected_mutations), "white-space"="nowrap", lineHeight='50%') %>%
    formatRound(columns="Zscore", digits=3)
} else {
  cat(paste0("No hotspot mutations were identified for ", target))
}
rm(tcga_res_info, mutation_counts, mutations)
```
\
\
\
\


#### Survival analyses

To quantify an effect size for a single variable - here gene expression, copy-number alteration and mutation- in survival outcomes, we used Cox regression models. The quantity of interest from a Cox regression model is a **hazard ratio (HR)**. The HR represents the ratio of hazards between two groups at any particular point in time. The HR is interpreted as the instantaneous rate of occurrence of the event of interest in those who are still at risk for the event. It is not a risk, though it is commonly misinterpreted as such. A HR < 1 indicates reduced hazard of death whereas a HR > 1 indicates an increased hazard of death.
\


```{r, echo=FALSE, warning=FALSE}
survival_expression <- fread("~/New_targets/Target_profile/input_data/cBioPortal/CoxPH_TCGA_expression_results.csv", header = T, data.table = F)
survival_expression <- survival_expression[survival_expression$Variable == target,]
survival_expression <- survival_expression[order(survival_expression$P, decreasing = F),]
survival_expression$TCGA_study <- str_to_upper(survival_expression$TCGA_study)
colnames(survival_expression)[14] <- "FDR"
survival_expression <- survival_expression[, c("TCGA_study", "Term", "HR", "StandardError", "Z", "P", "FDR")]

survival_cna <- fread("~/New_targets/Target_profile/input_data/cBioPortal/CoxPH_TCGA_cna_log2_results.csv", header = T, data.table = F)
survival_cna<- survival_cna[survival_cna$Variable == target,]
survival_cna <- survival_cna[order(survival_cna$P, decreasing = F),]
survival_cna$TCGA_study <- str_to_upper(survival_cna$TCGA_study)
colnames(survival_cna)[14] <- "FDR"
survival_cna$Variable <- NULL
survival_cna <- survival_cna[, c("TCGA_study", "Term", "HR", "StandardError", "Z", "P", "FDR")]

survival_mutation <- fread("~/New_targets/Target_profile/input_data/cBioPortal/CoxPH_TCGA_mutation_results_iter.csv", header = T, data.table = F)
survival_mutation <- survival_mutation[survival_mutation$term %in% paste0(target, c("LOW", "MODERATE", "HIGH")),]
survival_mutation <- survival_mutation[order(survival_mutation$p.value, decreasing = F),]
survival_mutation$TCGA_study <- str_to_upper(survival_mutation$TCGA_study)
colnames(survival_mutation)[2:9] <- c("Term", "HR", "StandardError", "Z", "P", "HRlower", "HRupper", "FDR")
survival_mutation <- survival_mutation[, c("TCGA_study", "Term", "HR", "StandardError", "Z", "P", "FDR")]
```

**Survival expression**

```{r, echo=FALSE, warning=FALSE}
datatable(survival_expression, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(survival_expression), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = names(survival_expression)[3:ncol(survival_expression)], digits = 3) %>% formatStyle(
  "P", target = "row",
  backgroundColor = styleInterval(0.05, c("yellow","white")))
```

**Survival copy-number alterations**

```{r, echo=FALSE, warning=FALSE}
datatable(survival_cna, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(survival_cna), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = names(survival_cna)[3:ncol(survival_cna)], digits = 3) %>% formatStyle(
  "P", target = "row",
  backgroundColor = styleInterval(0.05, c("yellow","white")))
```

**Survival mutations**

```{r, echo=FALSE, warning=FALSE}
datatable(survival_mutation, rownames = FALSE,
          extensions = 'Buttons',
          filter = "top",
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(survival_mutation), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = names(survival_mutation)[3:ncol(survival_mutation)], digits = 3) %>% formatStyle(
  "P", target = "row",
  backgroundColor = styleInterval(0.05, c("yellow","white")))
```
\
\

#### Network analysis

To prioritize targets based on Protein-Protein Interactions (PPI) to known oncodrivers, we built a human PPI network using interactions with a confidence score of 400 or above, and performed Random Walks starting from 783 oncodrivers in total (464 RNA oncogenes plus another 319 known oncodrivers). This allowed us to rank all human proteins in the network by their importance relative to oncodriver genes. Below, we extract the **PageRank** score and **Ranking** of `r target` based on this analysis. **Interesting targets should be ranked near the top.**

```{r, echo=FALSE, warning=FALSE, results='asis'}
network_analysis_res <- read.table("~/New_targets/Target_profile/input_data/STRINGdb/STRING_full_ppagerank_all.tsv", header = T, sep = "\t")
N_proteins <- length(network_analysis_res$Protein)
if (target %in% network_analysis_res$Protein) {
  network_analysis_res <- network_analysis_res[network_analysis_res$Protein == target,]
  network_analysis_res$Ranking <- paste0(network_analysis_res$Rank, "/", N_proteins)
  network_analysis_res$Rank <- NULL
  datatable(network_analysis_res[,c(1,2,4,3)], rownames = FALSE,
            options = list(
              dom = 'Bfrtip',
              pageLength = 10,
              buttons = 'csv',
              scrollX = TRUE,
              scrollCollapse = TRUE
            )) %>% formatStyle(columns = names(network_analysis_res), lineHeight='50%', "white-space"="nowrap") %>% formatRound(columns = "PageRank", digits = 5) %>% formatStyle(
              "Ranking",
              backgroundColor = "yellow")
} else {
  cat(paste0("No data available for ", target))
}
```

\

Query one human protein or multiple space seperated proteins in STRING database:
```{r, echo=FALSE, warning=FALSE}
target_embedding = paste0("sed -e 's/GLI3/", target, "/g' ~/New_targets/Target_profile/input_data/embeddings/string_embedding_v1.html > ~/New_targets/Target_profile/input_data/embeddings/target_string_embedding.html")
system(target_embedding)
```

````{=html}
```{r, echo=FALSE, results='asis'}
xfun::file_string("~/New_targets/Target_profile/input_data/embeddings/target_string_embedding.html")
```
````

\

#### Subcellular localisation

COMPARTMENTS is a web resource that integrates evidence on protein subcellular localisation from manually curated literature, high-throughput screens, automatic text mining, and sequence-based prediction methods. All evidence is mapped to common protein identifiers and Gene Ontology terms, and further unified by assigning confidence scores (1 to 5).
\
\

**`r target` localisations - Knowledge**

```{r, echo=FALSE, warning=FALSE, results='asis', message=FALSE}
compartments_data <- fread(input = "~/New_targets/Target_profile/input_data/COMPARTMENTS/human_compartment_knowledge_full.tsv", data.table = F, sep = "\t", check.names = F, header = F)
colnames(compartments_data) <- c("Ensembl", "Gene_symbol", "GO_term", "Name", "Source", "Evidence", "Confidence")

if (target %in% compartments_data$Gene_symbol) {
compartments_data <- compartments_data[compartments_data$Gene_symbol == target,]
compartments_data <- compartments_data %>% group_by(Ensembl, Gene_symbol, GO_term, Name) %>%
    summarise(Sources = paste0(unique(paste0(Source, "-", Evidence)), collapse = "/"), Top_score = max(Confidence))
datatable(compartments_data, rownames = FALSE,
          options = list(
            dom = 'Bfrtip',
            pageLength = 10,
            buttons = 'csv',
            scrollX = TRUE,
            scrollCollapse = TRUE
          )) %>% formatStyle(columns = names(compartments_data), lineHeight='50%', "white-space"="nowrap")
} else {
  cat(paste0("No data available for ", target))
}
```

\
\
\
\
\
\
